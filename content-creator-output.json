{
  "topic": "Core Java Fundamentals and OOP Principles",
  "questions": [
    {
      "question": "What are the four pillars of Object-Oriented Programming?",
      "answer": "The four pillars of OOP are:\n1. **Encapsulation**: Bundling data (variables) and methods that operate on the data within a single unit (class), and restricting direct access to some components through access modifiers (private, protected, public).\n2. **Inheritance**: A mechanism where a new class inherits properties and behaviors from an existing class, promoting code reusability.\n3. **Polymorphism**: The ability of objects to take many forms, allowing methods to behave differently based on the object calling them (method overloading and overriding).\n4. **Abstraction**: Hiding complex implementation details and showing only essential features to the user, achieved through abstract classes and interfaces."
    },
    {
      "question": "Explain the difference between JDK, JRE, and JVM.",
      "answer": "**JVM (Java Virtual Machine)**: The runtime engine that executes Java bytecode. It provides platform independence and manages memory through garbage collection.\n\n**JRE (Java Runtime Environment)**: Contains the JVM along with core libraries and other components necessary to run Java applications. It includes JVM + library classes.\n\n**JDK (Java Development Kit)**: A complete development environment that includes the JRE plus development tools like compiler (javac), debugger, and other utilities needed to develop Java applications.\n\nRelationship: JDK = JRE + Development Tools; JRE = JVM + Library Classes"
    },
    {
      "question": "What is the difference between == and equals() in Java?",
      "answer": "**== operator**: Compares references (memory addresses) for objects and values for primitives.\n- For primitives: Compares actual values\n- For objects: Checks if both references point to the same object in memory\n\n**equals() method**: Compares the content/state of objects.\n- Default implementation in Object class uses == (reference comparison)\n- Should be overridden to provide meaningful content comparison\n- String class overrides equals() to compare character sequences\n\nExample:\n```java\nString s1 = new String(\"hello\");\nString s2 = new String(\"hello\");\ns1 == s2;        // false (different objects)\ns1.equals(s2);   // true (same content)\n```"
    },
    {
      "question": "What is method overloading and method overriding?",
      "answer": "**Method Overloading (Compile-time Polymorphism)**:\n- Multiple methods with the same name but different parameters in the same class\n- Different parameter list: type, number, or order\n- Return type can be different but cannot be the only difference\n- Resolved at compile time\n\n```java\nclass Calculator {\n    int add(int a, int b) { return a + b; }\n    double add(double a, double b) { return a + b; }\n    int add(int a, int b, int c) { return a + b + c; }\n}\n```\n\n**Method Overriding (Runtime Polymorphism)**:\n- Subclass provides specific implementation of a method declared in parent class\n- Same method signature (name, parameters, return type)\n- Must not have more restrictive access modifier\n- Resolved at runtime\n- Uses @Override annotation\n\n```java\nclass Animal {\n    void sound() { System.out.println(\"Animal sound\"); }\n}\nclass Dog extends Animal {\n    @Override\n    void sound() { System.out.println(\"Bark\"); }\n}\n```"
    },
    {
      "question": "Explain the concept of inheritance and its types in Java.",
      "answer": "**Inheritance** is a mechanism where one class acquires the properties and behaviors of another class using the 'extends' keyword.\n\n**Types of Inheritance**:\n\n1. **Single Inheritance**: A class inherits from one parent class\n   ```java\n   class B extends A { }\n   ```\n\n2. **Multilevel Inheritance**: A class inherits from a derived class\n   ```java\n   class C extends B extends A { }\n   ```\n\n3. **Hierarchical Inheritance**: Multiple classes inherit from one parent\n   ```java\n   class B extends A { }\n   class C extends A { }\n   ```\n\n4. **Multiple Inheritance**: NOT supported with classes (to avoid diamond problem), but achieved through interfaces\n   ```java\n   interface A { }\n   interface B { }\n   class C implements A, B { }\n   ```\n\n5. **Hybrid Inheritance**: Combination of multiple types, achieved through interfaces\n\n**Key Points**:\n- Java supports only single inheritance with classes\n- Multiple inheritance is possible through interfaces\n- Uses 'super' keyword to access parent class members\n- Constructor chaining: super() must be first statement"
    },
    {
      "question": "What is encapsulation and how is it achieved in Java?",
      "answer": "**Encapsulation** is the bundling of data and methods that operate on that data within a single unit (class), and restricting direct access to some components.\n\n**How to Achieve Encapsulation**:\n\n1. **Declare variables as private**\n2. **Provide public getter and setter methods** to access and modify private variables\n\n```java\npublic class Employee {\n    private String name;\n    private int age;\n    \n    // Getter\n    public String getName() {\n        return name;\n    }\n    \n    // Setter with validation\n    public void setAge(int age) {\n        if (age > 0 && age < 150) {\n            this.age = age;\n        }\n    }\n}\n```\n\n**Benefits**:\n- **Data Hiding**: Internal state is hidden from outside\n- **Control**: Can add validation logic in setters\n- **Flexibility**: Can change internal implementation without affecting external code\n- **Increased Security**: Prevents unauthorized access\n- **Read-only or Write-only**: Can provide only getter (read-only) or only setter (write-only)\n- **Better Maintainability**: Changes are localized"
    },
    {
      "question": "What is abstraction and how is it different from encapsulation?",
      "answer": "**Abstraction**: Hiding complex implementation details and showing only essential features. It focuses on WHAT an object does rather than HOW it does it.\n\n**Achieved through**:\n1. **Abstract Classes**: Can have both abstract and concrete methods\n2. **Interfaces**: All methods are abstract by default (before Java 8)\n\n```java\nabstract class Vehicle {\n    abstract void start();  // Abstract method\n    void stop() {           // Concrete method\n        System.out.println(\"Vehicle stopped\");\n    }\n}\n\ninterface Drawable {\n    void draw();  // Abstract by default\n}\n```\n\n**Abstraction vs Encapsulation**:\n\n| Aspect | Abstraction | Encapsulation |\n|--------|-------------|---------------|\n| Purpose | Hide complexity | Hide data |\n| Focus | Design level | Implementation level |\n| Implementation | Abstract classes, Interfaces | Access modifiers, getters/setters |\n| Question Answered | What to do? | How to protect? |\n| Example | Car interface with drive() | Private variables with public methods |\n\n**Key Point**: Abstraction is about hiding complexity at design level, while encapsulation is about bundling data and controlling access at implementation level."
    },
    {
      "question": "Explain the concept of polymorphism with examples.",
      "answer": "**Polymorphism** means \"many forms\" - the ability of an object to take many forms. It allows one interface to be used for a general class of actions.\n\n**Types of Polymorphism**:\n\n**1. Compile-time Polymorphism (Static Binding)**:\n- Achieved through method overloading\n- Resolved at compile time\n\n```java\nclass Calculator {\n    int add(int a, int b) { return a + b; }\n    double add(double a, double b) { return a + b; }\n}\n```\n\n**2. Runtime Polymorphism (Dynamic Binding)**:\n- Achieved through method overriding\n- Resolved at runtime\n- Requires inheritance and method overriding\n\n```java\nclass Animal {\n    void makeSound() { System.out.println(\"Some sound\"); }\n}\n\nclass Dog extends Animal {\n    @Override\n    void makeSound() { System.out.println(\"Bark\"); }\n}\n\nclass Cat extends Animal {\n    @Override\n    void makeSound() { System.out.println(\"Meow\"); }\n}\n\n// Usage\nAnimal animal1 = new Dog();  // Upcasting\nAnimal animal2 = new Cat();\nanimal1.makeSound();  // Output: Bark\nanimal2.makeSound();  // Output: Meow\n```\n\n**Benefits**:\n- Code flexibility and reusability\n- Loose coupling\n- Easier maintenance\n- Single interface for multiple implementations"
    },
    {
      "question": "What is the difference between abstract class and interface?",
      "answer": "**Abstract Class vs Interface**:\n\n| Feature | Abstract Class | Interface |\n|---------|---------------|------------|\n| **Keyword** | abstract | interface |\n| **Methods** | Can have abstract and concrete methods | All methods abstract (before Java 8) |\n| **Variables** | Can have instance variables | Only static final constants |\n| **Constructors** | Can have constructors | Cannot have constructors |\n| **Access Modifiers** | Any access modifier | Public by default |\n| **Inheritance** | Single inheritance (extends) | Multiple inheritance (implements) |\n| **Implementation** | Can provide partial implementation | No implementation (before Java 8) |\n| **When to use** | When classes share common behavior | When unrelated classes share common contract |\n\n**Java 8+ Changes**:\n- Interfaces can have default and static methods\n- Can have private methods (Java 9+)\n\n```java\n// Abstract Class\nabstract class Animal {\n    String name;  // Instance variable\n    \n    Animal(String name) {  // Constructor\n        this.name = name;\n    }\n    \n    abstract void makeSound();  // Abstract method\n    \n    void sleep() {  // Concrete method\n        System.out.println(name + \" is sleeping\");\n    }\n}\n\n// Interface\ninterface Flyable {\n    int MAX_SPEED = 100;  // static final constant\n    \n    void fly();  // Abstract method\n    \n    default void land() {  // Default method (Java 8+)\n        System.out.println(\"Landing...\");\n    }\n}\n```\n\n**Rule of Thumb**:\n- Use abstract class for IS-A relationship with common behavior\n- Use interface for CAN-DO capability across unrelated classes"
    },
    {
      "question": "What are access modifiers in Java and explain each one?",
      "answer": "Access modifiers control the visibility and accessibility of classes, methods, and variables.\n\n**Four Access Modifiers**:\n\n**1. private**:\n- Accessible only within the same class\n- Most restrictive\n- Used for encapsulation\n\n**2. default (package-private)**:\n- No keyword needed\n- Accessible within the same package only\n- Not accessible from other packages\n\n**3. protected**:\n- Accessible within the same package\n- Accessible in subclasses (even in different packages)\n- Cannot be applied to top-level classes\n\n**4. public**:\n- Accessible from anywhere\n- Least restrictive\n\n**Visibility Table**:\n\n| Modifier | Same Class | Same Package | Subclass | Other Packages |\n|----------|------------|--------------|----------|----------------|\n| private | ✓ | ✗ | ✗ | ✗ |\n| default | ✓ | ✓ | ✗ | ✗ |\n| protected | ✓ | ✓ | ✓ | ✗ |\n| public | ✓ | ✓ | ✓ | ✓ |\n\n```java\npublic class Example {\n    private int privateVar;      // Only in this class\n    int defaultVar;              // Package-private\n    protected int protectedVar;  // Package + subclasses\n    public int publicVar;        // Everywhere\n}\n```\n\n**Best Practices**:\n- Keep variables private\n- Use public for API methods\n- Use protected for methods meant for inheritance\n- Default for package-internal utilities"
    },
    {
      "question": "Explain static keyword in Java.",
      "answer": "**static** keyword is used for memory management and belongs to the class rather than instances.\n\n**Uses of static**:\n\n**1. Static Variables (Class Variables)**:\n- Shared among all instances\n- Memory allocated once at class loading\n- Accessed via class name\n\n```java\nclass Counter {\n    static int count = 0;  // Shared by all objects\n    \n    Counter() {\n        count++;\n    }\n}\n```\n\n**2. Static Methods**:\n- Can be called without creating an object\n- Can only access static members directly\n- Cannot use 'this' or 'super' keywords\n\n```java\nclass MathUtil {\n    static int add(int a, int b) {\n        return a + b;\n    }\n}\n// Call: MathUtil.add(5, 3);\n```\n\n**3. Static Blocks**:\n- Executed when class is loaded (before main method)\n- Used for static initialization\n\n```java\nclass Database {\n    static Connection conn;\n    \n    static {\n        // Initialize connection\n        conn = DriverManager.getConnection(url);\n    }\n}\n```\n\n**4. Static Nested Classes**:\n- Can access only static members of outer class\n- Don't need outer class instance\n\n```java\nclass Outer {\n    static class Inner {\n        void display() { }\n    }\n}\n```\n\n**Key Points**:\n- Static members belong to class, not objects\n- Loaded when class is loaded\n- Memory efficient (single copy)\n- Cannot access instance variables directly\n- Common uses: utility methods, constants, counters"
    },
    {
      "question": "What is the final keyword in Java?",
      "answer": "**final** keyword is used to apply restrictions and make things immutable.\n\n**Uses of final**:\n\n**1. Final Variables (Constants)**:\n- Value cannot be changed once assigned\n- Must be initialized when declared or in constructor\n- Convention: Use UPPERCASE with underscores\n\n```java\nfinal int MAX_VALUE = 100;\nfinal double PI = 3.14159;\n\nclass Config {\n    final String DB_URL;  // Blank final variable\n    \n    Config(String url) {\n        this.DB_URL = url;  // Initialized in constructor\n    }\n}\n```\n\n**2. Final Methods**:\n- Cannot be overridden by subclasses\n- Used to prevent modification of critical behavior\n\n```java\nclass Parent {\n    final void display() {\n        System.out.println(\"Cannot override this\");\n    }\n}\n\nclass Child extends Parent {\n    // void display() { }  // Compilation error\n}\n```\n\n**3. Final Classes**:\n- Cannot be extended/inherited\n- Prevents inheritance\n- Examples: String, Integer, System classes\n\n```java\nfinal class ImmutableClass {\n    // Cannot be inherited\n}\n\n// class SubClass extends ImmutableClass { }  // Error\n```\n\n**4. Final Parameters**:\n- Method parameters cannot be modified inside the method\n\n```java\nvoid process(final int value) {\n    // value = 20;  // Compilation error\n}\n```\n\n**Benefits**:\n- **Security**: Prevents unwanted modifications\n- **Thread Safety**: Immutable objects are thread-safe\n- **Performance**: JVM can optimize final variables\n- **Design**: Clearly indicates immutability\n\n**Important Notes**:\n- final variable: value immutable\n- final reference: reference immutable (object content can change)\n- final method: implementation immutable\n- final class: inheritance immutable"
    },
    {
      "question": "What is the difference between String, StringBuilder, and StringBuffer?",
      "answer": "**String vs StringBuilder vs StringBuffer**:\n\n| Feature | String | StringBuilder | StringBuffer |\n|---------|--------|---------------|-------------|\n| **Mutability** | Immutable | Mutable | Mutable |\n| **Thread Safety** | Yes (immutable) | No | Yes (synchronized) |\n| **Performance** | Slow for modifications | Fast | Slower than StringBuilder |\n| **Memory** | Creates new object on change | Modifies same object | Modifies same object |\n| **When to use** | Fixed strings | Single-threaded string manipulation | Multi-threaded string manipulation |\n\n**String (Immutable)**:\n```java\nString s = \"Hello\";\ns = s + \" World\";  // Creates new String object\n// Original \"Hello\" object remains in memory (garbage)\n```\n\n**StringBuilder (Mutable, Not Synchronized)**:\n```java\nStringBuilder sb = new StringBuilder(\"Hello\");\nsb.append(\" World\");  // Modifies same object\nString result = sb.toString();\n// Best for single-threaded scenarios\n```\n\n**StringBuffer (Mutable, Synchronized)**:\n```java\nStringBuffer sbf = new StringBuffer(\"Hello\");\nsbf.append(\" World\");  // Thread-safe, modifies same object\nString result = sbf.toString();\n// Best for multi-threaded scenarios\n```\n\n**Performance Comparison**:\n- String concatenation in loop: Creates multiple objects (very slow)\n- StringBuilder: Fast, no synchronization overhead\n- StringBuffer: Slightly slower due to synchronization\n\n**Common Methods**:\n- append(), insert(), delete(), replace(), reverse()\n- capacity(), length(), charAt()\n\n**Best Practice**:\n- Use String for fixed/constant strings\n- Use StringBuilder for string manipulation (most common)\n- Use StringBuffer only when thread safety is required\n- For small concatenations, String is fine (compiler optimizes)"
    },
    {
      "question": "Explain constructor in Java and its types.",
      "answer": "**Constructor** is a special method used to initialize objects. It has the same name as the class and no return type.\n\n**Types of Constructors**:\n\n**1. Default Constructor (No-arg)**:\n- No parameters\n- Compiler provides if no constructor is defined\n- Initializes instance variables with default values\n\n```java\nclass Student {\n    String name;\n    int age;\n    \n    // Default constructor\n    Student() {\n        name = \"Unknown\";\n        age = 0;\n    }\n}\n```\n\n**2. Parameterized Constructor**:\n- Takes parameters to initialize object with specific values\n- Enables object creation with different initial states\n\n```java\nclass Student {\n    String name;\n    int age;\n    \n    // Parameterized constructor\n    Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n```\n\n**3. Copy Constructor**:\n- Creates object by copying values from another object\n- Not automatically provided (must be implemented)\n\n```java\nclass Student {\n    String name;\n    int age;\n    \n    // Copy constructor\n    Student(Student other) {\n        this.name = other.name;\n        this.age = other.age;\n    }\n}\n```\n\n**Constructor Chaining**:\n- Calling one constructor from another using this() or super()\n\n```java\nclass Student {\n    String name;\n    int age;\n    \n    Student() {\n        this(\"Unknown\", 0);  // Calls parameterized constructor\n    }\n    \n    Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n```\n\n**Key Points**:\n- Constructor name must match class name\n- No return type (not even void)\n- Called automatically when object is created\n- Can be overloaded\n- this() or super() must be first statement\n- If you define any constructor, compiler won't provide default\n- Cannot be abstract, static, final, or synchronized"
    },
    {
      "question": "What is the super keyword in Java?",
      "answer": "**super** keyword is a reference variable used to refer to the immediate parent class object.\n\n**Uses of super keyword**:\n\n**1. Access Parent Class Variables**:\n- When child and parent have same variable names\n\n```java\nclass Parent {\n    int num = 10;\n}\n\nclass Child extends Parent {\n    int num = 20;\n    \n    void display() {\n        System.out.println(num);        // 20 (child)\n        System.out.println(super.num);  // 10 (parent)\n    }\n}\n```\n\n**2. Call Parent Class Methods**:\n- When child overrides parent method but wants to call parent version\n\n```java\nclass Parent {\n    void display() {\n        System.out.println(\"Parent display\");\n    }\n}\n\nclass Child extends Parent {\n    @Override\n    void display() {\n        super.display();  // Call parent method\n        System.out.println(\"Child display\");\n    }\n}\n```\n\n**3. Call Parent Class Constructor**:\n- Must be first statement in child constructor\n- If not explicitly called, compiler adds super() automatically\n\n```java\nclass Parent {\n    Parent() {\n        System.out.println(\"Parent constructor\");\n    }\n    \n    Parent(String msg) {\n        System.out.println(\"Parent: \" + msg);\n    }\n}\n\nclass Child extends Parent {\n    Child() {\n        super(\"Hello\");  // Call parameterized parent constructor\n        System.out.println(\"Child constructor\");\n    }\n}\n```\n\n**this vs super**:\n\n| Aspect | this | super |\n|--------|------|-------|\n| Reference | Current class | Parent class |\n| Usage | Access current class members | Access parent class members |\n| Constructor | this() calls current class constructor | super() calls parent class constructor |\n| When used | Differentiate between instance and local variables | Access overridden methods/variables |\n\n**Important Rules**:\n- super() must be first statement in constructor\n- Cannot use both this() and super() in same constructor\n- super can be used in methods to call parent implementation\n- Cannot use super in static context"
    }
  ]
}
