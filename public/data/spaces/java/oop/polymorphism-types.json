{
  "id": "polymorphism-types",
  "title": "What are the types of polymorphism?",
  "answers": {
    "junior": "Polymorphism means 'many forms'. In Java, there are two types: Compile-time polymorphism (method overloading) and Runtime polymorphism (method overriding). It allows objects to take different forms.",
    "middle": "Java supports two types of polymorphism: 1) Compile-time (Static) Polymorphism - achieved through method overloading and operator overloading (limited in Java). Method overloading allows multiple methods with the same name but different parameters. 2) Runtime (Dynamic) Polymorphism - achieved through method overriding where a subclass provides a specific implementation of a method declared in its parent class. The JVM determines which method to call at runtime based on the actual object type.",
    "senior": "Polymorphism in Java: 1) Static Polymorphism (early binding) - resolved at compile-time via method overloading, including varargs and autoboxing considerations. Overload resolution follows specific rules for matching arguments. 2) Dynamic Polymorphism (late binding) - uses virtual method invocation where the method call is resolved at runtime through the object's actual class, not reference type. Implemented via method tables (vtables) in the JVM. Covariant return types allow overridden methods to return subclass types. The combination with interfaces enables strategy patterns and dependency injection.",
    "tricky": "Advanced considerations: Static methods and private methods can't be polymorphic (they're bound at compile-time). Constructor overloading is technically static polymorphism but constructors aren't inherited. Generic type erasure affects polymorphism at runtime (List<String> and List<Integer> are the same at runtime). Bridge methods are generated by the compiler for generic polymorphism. Performance: virtual method calls have slight overhead compared to static dispatch, though JIT optimization with method inlining can eliminate this. Understanding invokespecial vs invokevirtual bytecode instructions is crucial for optimization."
  }
}
