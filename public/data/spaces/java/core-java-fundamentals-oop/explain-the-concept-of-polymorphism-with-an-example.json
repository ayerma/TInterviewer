{
  "id": "explain-the-concept-of-polymorphism-with-an-example",
  "title": "Explain the concept of polymorphism with an example.",
  "answers": {
    "junior": "Polymorphism, derived from Greek meaning 'many forms', is a core OOP principle that allows objects of different classes to be treated as objects of a common superclass, enabling a single interface to represent different underlying forms. Java supports two types of polymorphism: compile-time (method overloading) and runtime (method overriding).",
    "middle": "Polymorphism, derived from Greek meaning 'many forms', is a core OOP principle that allows objects of different classes to be treated as objects of a common superclass, enabling a single interface to represent different underlying forms. Java supports two types of polymorphism: compile-time (method overloading) and runtime (method overriding). Runtime polymorphism is achieved through inheritance and interfaces, where a parent class reference can point to child class objects, and the actual method executed is determined at runtime based on the object type, not the reference type. For example: `Animal animal = new Dog(); animal.makeSound();` - if Dog overrides makeSound(), the Dog's implementation executes even though the reference is of type Animal.",
    "senior": "Polymorphism, derived from Greek meaning 'many forms', is a core OOP principle that allows objects of different classes to be treated as objects of a common superclass, enabling a single interface to represent different underlying forms. Java supports two types of polymorphism: compile-time (method overloading) and runtime (method overriding). Runtime polymorphism is achieved through inheritance and interfaces, where a parent class reference can point to child class objects, and the actual method executed is determined at runtime based on the object type, not the reference type. For example: `Animal animal = new Dog(); animal.makeSound();` - if Dog overrides makeSound(), the Dog's implementation executes even though the reference is of type Animal. This is powered by dynamic method dispatch in the JVM. A practical example: `class Animal { void makeSound() { System.out.println(\"Some sound\"); } } class Dog extends Animal { @Override void makeSound() { System.out.println(\"Bark\"); } } class Cat extends Animal { @Override void makeSound() { System.out.println(\"Meow\"); } }` - now you can write `List<Animal> animals = Arrays.asList(new Dog(), new Cat()); animals.forEach(Animal::makeSound);` and each animal produces its specific sound. Polymorphism is fundamental for designing flexible, extensible systems, enabling principles like dependency inversion and programming to interfaces rather than implementations. Key benefits include code reusability, loose coupling, and the ability to add new types without modifying existing code that uses the base type.",
    "tricky": "Polymorphism, derived from Greek meaning 'many forms', is a core OOP principle that allows objects of different classes to be treated as objects of a common superclass, enabling a single interface to represent different underlying forms. Java supports two types of polymorphism: compile-time (method overloading) and runtime (method overriding). Runtime polymorphism is achieved through inheritance and interfaces, where a parent class reference can point to child class objects, and the actual method executed is determined at runtime based on the object type, not the reference type. For example: `Animal animal = new Dog(); animal.makeSound();` - if Dog overrides makeSound(), the Dog's implementation executes even though the reference is of type Animal. This is powered by dynamic method dispatch in the JVM. A practical example: `class Animal { void makeSound() { System.out.println(\"Some sound\"); } } class Dog extends Animal { @Override void makeSound() { System.out.println(\"Bark\"); } } class Cat extends Animal { @Override void makeSound() { System.out.println(\"Meow\"); } }` - now you can write `List<Animal> animals = Arrays.asList(new Dog(), new Cat()); animals.forEach(Animal::makeSound);` and each animal produces its specific sound. Polymorphism is fundamental for designing flexible, extensible systems, enabling principles like dependency inversion and programming to interfaces rather than implementations. Key benefits include code reusability, loose coupling, and the ability to add new types without modifying existing code that uses the base type. Important consideration: polymorphism only works with instance methods, not static methods or private methods, and the actual object type determines which overridden method executes at runtime."
  }
}