{
  "id": "how-does-java-achieve-memory-management-through-garbage",
  "title": "How does Java achieve memory management through Garbage Collection?",
  "answers": {
    "junior": "Java achieves automatic memory management through Garbage Collection (GC), which automatically reclaims memory occupied by objects that are no longer reachable from any live thread. The JVM heap is divided into generations: Young Generation (Eden + Survivor spaces) and Old Generation (Tenured space), based on the observation that most objects die young.",
    "middle": "Java achieves automatic memory management through Garbage Collection (GC), which automatically reclaims memory occupied by objects that are no longer reachable from any live thread. The JVM heap is divided into generations: Young Generation (Eden + Survivor spaces) and Old Generation (Tenured space), based on the observation that most objects die young. When objects are created, they're allocated in Eden; during minor GC, surviving objects move to Survivor spaces, and after multiple survivals, they're promoted to Old Generation. Major GC (Full GC) cleans the Old Generation and is more expensive. Java provides multiple GC algorithms: Serial GC (single-threaded, suitable for small apps), Parallel GC (multiple threads, throughput-focused), CMS (Concurrent Mark Sweep, low-pause), G1 GC (default since Java 9, predictable pause times), ZGC and Shenandoah (ultra-low latency for large heaps).",
    "senior": "Java achieves automatic memory management through Garbage Collection (GC), which automatically reclaims memory occupied by objects that are no longer reachable from any live thread. The JVM heap is divided into generations: Young Generation (Eden + Survivor spaces) and Old Generation (Tenured space), based on the observation that most objects die young. When objects are created, they're allocated in Eden; during minor GC, surviving objects move to Survivor spaces, and after multiple survivals, they're promoted to Old Generation. Major GC (Full GC) cleans the Old Generation and is more expensive. Java provides multiple GC algorithms: Serial GC (single-threaded, suitable for small apps), Parallel GC (multiple threads, throughput-focused), CMS (Concurrent Mark Sweep, low-pause), G1 GC (default since Java 9, predictable pause times), ZGC and Shenandoah (ultra-low latency for large heaps). The GC process involves marking reachable objects starting from GC roots (static variables, active threads, JNI references), then sweeping unmarked objects. Example: `System.gc()` suggests GC but doesn't guarantee immediate execution; proper memory management involves avoiding memory leaks through strong references in collections like `Map<String, Object> cache = new HashMap<>();` which prevents GC. Modern GC algorithms use techniques like card tables, remembered sets, and concurrent marking to minimize pause times.",
    "tricky": "Java achieves automatic memory management through Garbage Collection (GC), which automatically reclaims memory occupied by objects that are no longer reachable from any live thread. The JVM heap is divided into generations: Young Generation (Eden + Survivor spaces) and Old Generation (Tenured space), based on the observation that most objects die young. When objects are created, they're allocated in Eden; during minor GC, surviving objects move to Survivor spaces, and after multiple survivals, they're promoted to Old Generation. Major GC (Full GC) cleans the Old Generation and is more expensive. Java provides multiple GC algorithms: Serial GC (single-threaded, suitable for small apps), Parallel GC (multiple threads, throughput-focused), CMS (Concurrent Mark Sweep, low-pause), G1 GC (default since Java 9, predictable pause times), ZGC and Shenandoah (ultra-low latency for large heaps). The GC process involves marking reachable objects starting from GC roots (static variables, active threads, JNI references), then sweeping unmarked objects. Example: `System.gc()` suggests GC but doesn't guarantee immediate execution; proper memory management involves avoiding memory leaks through strong references in collections like `Map<String, Object> cache = new HashMap<>();` which prevents GC. Modern GC algorithms use techniques like card tables, remembered sets, and concurrent marking to minimize pause times. Tuning involves JVM flags like `-Xmx` (max heap), `-Xms` (initial heap), `-XX:+UseG1GC`, and monitoring with tools like JVisualVM or GC logs. Key insight: while GC automates memory management, developers must still avoid memory leaks by clearing references, using weak references when appropriate (`WeakReference<Object> ref = new WeakReference<>(obj);`), and properly closing resources. Understanding GC behavior is crucial for production applications to balance throughput, latency, and memory footprint."
  }
}