{
  "id": "what-are-some-common-pitfalls-or-anti-patterns-in-applying",
  "title": "What are some common pitfalls or anti-patterns in applying OOP principles in Java?",
  "answers": {
    "junior": "One of the most common pitfalls is creating **God Objects** - classes that know too much or do too much, violating the Single Responsibility Principle. For example, a `UserManager` class that handles validation, database operations, email notifications, and authentication should be split into focused classes like `UserValidator`, `UserRepository`, `EmailService`, and `AuthenticationService`. Another major anti-pattern is **inheritance abuse** where developers use inheritance for code reuse rather than modeling true \"is-a\" relationships; composition should be preferred in most cases.",
    "middle": "One of the most common pitfalls is creating **God Objects** - classes that know too much or do too much, violating the Single Responsibility Principle. For example, a `UserManager` class that handles validation, database operations, email notifications, and authentication should be split into focused classes like `UserValidator`, `UserRepository`, `EmailService`, and `AuthenticationService`. Another major anti-pattern is **inheritance abuse** where developers use inheritance for code reuse rather than modeling true \"is-a\" relationships; composition should be preferred in most cases. **Breaking encapsulation** by exposing internal state through public fields or returning mutable collections directly (e.g., `public List<String> getItems() { return items; }` should return `Collections.unmodifiableList(items)` or a defensive copy) is a frequent mistake. **Deep inheritance hierarchies** (more than 3-4 levels) make code fragile and hard to understand; favoring composition and interfaces provides better flexibility. The **anemic domain model** anti-pattern creates objects that are mere data holders with no behavior, pushing all logic into service classes and defeating the purpose of OOP.",
    "senior": "One of the most common pitfalls is creating **God Objects** - classes that know too much or do too much, violating the Single Responsibility Principle. For example, a `UserManager` class that handles validation, database operations, email notifications, and authentication should be split into focused classes like `UserValidator`, `UserRepository`, `EmailService`, and `AuthenticationService`. Another major anti-pattern is **inheritance abuse** where developers use inheritance for code reuse rather than modeling true \"is-a\" relationships; composition should be preferred in most cases. **Breaking encapsulation** by exposing internal state through public fields or returning mutable collections directly (e.g., `public List<String> getItems() { return items; }` should return `Collections.unmodifiableList(items)` or a defensive copy) is a frequent mistake. **Deep inheritance hierarchies** (more than 3-4 levels) make code fragile and hard to understand; favoring composition and interfaces provides better flexibility. The **anemic domain model** anti-pattern creates objects that are mere data holders with no behavior, pushing all logic into service classes and defeating the purpose of OOP. **Violating Liskov Substitution Principle** occurs when subclasses don't properly substitute their parent classes, such as a `Square` extending `Rectangle` where `setWidth()` and `setHeight()` behave unexpectedly. **Interface pollution** happens when interfaces become bloated with too many methods, forcing implementers to provide stub implementations; this violates Interface Segregation Principle. **Tight coupling** through concrete class dependencies rather than abstractions makes testing difficult and reduces flexibility; always depend on interfaces or abstract classes when possible.",
    "tricky": "One of the most common pitfalls is creating **God Objects** - classes that know too much or do too much, violating the Single Responsibility Principle. For example, a `UserManager` class that handles validation, database operations, email notifications, and authentication should be split into focused classes like `UserValidator`, `UserRepository`, `EmailService`, and `AuthenticationService`. Another major anti-pattern is **inheritance abuse** where developers use inheritance for code reuse rather than modeling true \"is-a\" relationships; composition should be preferred in most cases. **Breaking encapsulation** by exposing internal state through public fields or returning mutable collections directly (e.g., `public List<String> getItems() { return items; }` should return `Collections.unmodifiableList(items)` or a defensive copy) is a frequent mistake. **Deep inheritance hierarchies** (more than 3-4 levels) make code fragile and hard to understand; favoring composition and interfaces provides better flexibility. The **anemic domain model** anti-pattern creates objects that are mere data holders with no behavior, pushing all logic into service classes and defeating the purpose of OOP. **Violating Liskov Substitution Principle** occurs when subclasses don't properly substitute their parent classes, such as a `Square` extending `Rectangle` where `setWidth()` and `setHeight()` behave unexpectedly. **Interface pollution** happens when interfaces become bloated with too many methods, forcing implementers to provide stub implementations; this violates Interface Segregation Principle. **Tight coupling** through concrete class dependencies rather than abstractions makes testing difficult and reduces flexibility; always depend on interfaces or abstract classes when possible. **Primitive obsession** uses primitives instead of small objects (e.g., using `String` for email addresses instead of an `Email` value object with validation). Finally, **not using polymorphism** and relying on type checking with `instanceof` or switch statements on type codes indicates missing abstractions; for example, instead of checking `if (shape instanceof Circle)`, use polymorphic method `shape.calculateArea()`. These anti-patterns lead to rigid, fragile code that's difficult to maintain, test, and extend."
  }
}